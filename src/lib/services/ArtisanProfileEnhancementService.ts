/**
 * Artisan Profile Enhancement Service
 * 
 * This service automatically enhances artisan profiles with matching metadata,
 * extracts keywords from existing data, and creates comprehensive matching profiles.
 */

import { IUser } from '../models/User';
import { GoogleGenerativeAIService } from './GoogleGenerativeAIService';
import { ProfessionMappingService } from './ProfessionMappingService';

export interface EnhancedMatchingProfile {
  uid: string;
  professionCategories: string[];
  primaryMaterials: string[];
  techniques: string[];
  specializations: string[];
  styleExpertise: string[];
  productTypes: string[];
  qualityLevel: 'premium' | 'standard' | 'basic';
  experienceLevel: 'master' | 'experienced' | 'intermediate' | 'beginner';
  matchingKeywords: string[];
  portfolioKeywords: string[];
  categoryTags: string[];
  lastUpdated: Date;
  autoGenerated: boolean;
  confidence: number;
}

export interface ProfileAnalysisResult {
  extractedKeywords: string[];
  detectedMaterials: string[];
  identifiedTechniques: string[];
  suggestedCategories: string[];
  qualityIndicators: string[];
  experienceIndicators: string[];
  confidence: number;
}

export class ArtisanProfileEnhancementService {
  private static instance: ArtisanProfileEnhancementService;
  private aiService: GoogleGenerativeAIService;
  private mappingService: ProfessionMappingService;
  
  // Predefined keyword mappings for different professions
  private professionKeywords = {
    pottery: {
      materials: ['clay', 'ceramic', 'terracotta', 'porcelain', 'earthenware', 'stoneware', 'glaze'],
      techniques: ['throwing', 'glazing', 'firing', 'molding', 'hand-building', 'wheel-throwing', 'kiln'],
      products: ['pots', 'vases', 'bowls', 'plates', 'cups', 'tiles', 'sculptures', 'planters'],
      keywords: ['pottery', 'ceramic', 'clay work', 'handmade pottery', 'artisan ceramics']
    },
    woodworking: {
      materials: ['wood', 'timber', 'oak', 'pine', 'teak', 'mahogany', 'bamboo', 'plywood'],
      techniques: ['carving', 'turning', 'joinery', 'sanding', 'polishing', 'inlay', 'marquetry'],
      products: ['furniture', 'doors', 'windows', 'tables', 'chairs', 'cabinets', 'boxes', 'frames'],
      keywords: ['woodworking', 'carpentry', 'furniture making', 'wood craft', 'custom furniture']
    },
    jewelry: {
      materials: ['gold', 'silver', 'platinum', 'copper', 'brass', 'diamonds', 'pearls', 'gemstones'],
      techniques: ['casting', 'soldering', 'oxidizing', 'engraving', 'stone-setting', 'filigree'],
      products: ['rings', 'necklaces', 'earrings', 'bracelets', 'pendants', 'brooches', 'chains'],
      keywords: ['jewelry', 'handmade jewelry', 'custom jewelry', 'artisan jewelry', 'precious metals']
    },
    textiles: {
      materials: ['cotton', 'silk', 'wool', 'linen', 'jute', 'hemp', 'polyester', 'rayon'],
      techniques: ['weaving', 'spinning', 'dyeing', 'printing', 'knitting', 'crocheting'],
      products: ['sarees', 'fabrics', 'carpets', 'rugs', 'tapestries', 'clothing', 'blankets'],
      keywords: ['textiles', 'weaving', 'handwoven', 'fabric art', 'traditional textiles']
    },
    'leather work': {
      materials: ['leather', 'suede', 'hide', 'patent leather', 'nubuck'],
      techniques: ['tanning', 'tooling', 'stamping', 'stitching', 'embossing', 'dyeing'],
      products: ['bags', 'wallets', 'belts', 'shoes', 'jackets', 'purses', 'accessories'],
      keywords: ['leather work', 'leather craft', 'handmade leather', 'leather goods']
    },
    metalwork: {
      materials: ['iron', 'steel', 'brass', 'bronze', 'aluminum', 'copper', 'tin'],
      techniques: ['forging', 'welding', 'casting', 'hammering', 'engraving', 'patina'],
      products: ['sculptures', 'gates', 'railings', 'utensils', 'decorative items', 'tools'],
      keywords: ['metalwork', 'blacksmithing', 'metal craft', 'forged metal', 'custom metalwork']
    },
    painting: {
      materials: ['canvas', 'paper', 'wood', 'acrylic', 'oil', 'watercolor', 'tempera'],
      techniques: ['brushwork', 'glazing', 'impasto', 'wash', 'dry brush', 'stippling'],
      products: ['paintings', 'portraits', 'murals', 'illustrations', 'artwork', 'canvases'],
      keywords: ['painting', 'fine art', 'custom paintings', 'portrait art', 'decorative art']
    },
    embroidery: {
      materials: ['thread', 'yarn', 'silk thread', 'cotton thread', 'metallic thread', 'fabric'],
      techniques: ['hand stitching', 'machine embroidery', 'cross-stitch', 'chain stitch', 'satin stitch'],
      products: ['embroidered fabrics', 'decorative items', 'clothing', 'accessories', 'wall hangings'],
      keywords: ['embroidery', 'needlework', 'thread work', 'decorative stitching', 'custom embroidery']
    }
  };

  private constructor() {
    this.aiService = GoogleGenerativeAIService.getInstance();
    this.mappingService = ProfessionMappingService.getInstance();
  }

  public static getInstance(): ArtisanProfileEnhancementService {
    if (!ArtisanProfileEnhancementService.instance) {
      ArtisanProfileEnhancementService.instance = new ArtisanProfileEnhancementService();
    }
    return ArtisanProfileEnhancementService.instance;
  }

  /**
   * Enhance an artisan's profile with comprehensive matching metadata
   */
  public async enhanceArtisanProfile(artisan: IUser): Promise<EnhancedMatchingProfile> {
    try {
      // Analyze existing profile data
      const analysisResult = await this.analyzeExistingProfile(artisan);
      
      // Generate enhanced matching profile
      const enhancedProfile = this.generateEnhancedProfile(artisan, analysisResult);
      
      return enhancedProfile;
    } catch (error) {
      console.error('Error enhancing artisan profile:', error);
      
      // Return basic enhanced profile as fallback
      return this.generateBasicEnhancedProfile(artisan);
    }
  }

  /**
   * Batch enhance multiple artisan profiles
   */
  public async enhanceMultipleProfiles(artisans: IUser[]): Promise<EnhancedMatchingProfile[]> {
    const enhancedProfiles: EnhancedMatchingProfile[] = [];
    
    // Process in batches to avoid overwhelming the AI service
    const batchSize = 5;
    for (let i = 0; i < artisans.length; i += batchSize) {
      const batch = artisans.slice(i, i + batchSize);
      
      const batchPromises = batch.map(artisan => 
        this.enhanceArtisanProfile(artisan).catch(error => {
          console.error(`Error enhancing profile for ${artisan.uid}:`, error);
          return this.generateBasicEnhancedProfile(artisan);
        })
      );
      
      const batchResults = await Promise.all(batchPromises);
      enhancedProfiles.push(...batchResults);
      
      // Small delay between batches to respect rate limits
      if (i + batchSize < artisans.length) {
        await this.delay(1000);
      }
    }
    
    return enhancedProfiles;
  }

  /**
   * Extract keywords from artisan's description and portfolio
   */
  public async extractKeywordsFromProfile(artisan: IUser): Promise<string[]> {
    const textToAnalyze = this.gatherProfileText(artisan);
    
    if (!textToAnalyze.trim()) {
      return this.getDefaultKeywords(artisan.artisticProfession);
    }

    try {
      const prompt = this.buildKeywordExtractionPrompt(textToAnalyze, artisan.artisticProfession);
      const result = await this.aiService.analyzeQuery(prompt);
      
      // Extract keywords from AI response
      const extractedKeywords = this.parseKeywordsFromResponse(result);
      
      // Combine with profession-specific keywords
      const professionKeywords = this.getDefaultKeywords(artisan.artisticProfession);
      
      return [...new Set([...extractedKeywords, ...professionKeywords])];
    } catch (error) {
      console.error('Error extracting keywords:', error);
      return this.getDefaultKeywords(artisan.artisticProfession);
    }
  }

  /**
   * Update existing artisan profile with enhanced matching data
   */
  public updateArtisanMatchingData(
    artisan: IUser, 
    enhancedProfile: EnhancedMatchingProfile
  ): IUser {
    const updatedArtisan = { ...artisan };
    
    if (!updatedArtisan.artisanConnectProfile) {
      updatedArtisan.artisanConnectProfile = {
        virtualShowroomId: undefined,
        businessHours: {
          timezone: 'Asia/Kolkata',
          schedule: []
        },
        responseTimeAverage: 60,
        acceptsCustomOrders: true,
        specializations: [],
        culturalCertifications: [],
        portfolioHighlights: [],
        availabilityStatus: 'available',
        aiMetrics: {
          matchSuccessRate: 0,
          customerSatisfactionScore: 0,
          averageOrderValue: 0,
          completionRate: 0
        },
        skillTags: [],
        matchingData: {
          skills: [],
          materials: [],
          techniques: [],
          portfolioKeywords: [],
          averageProjectSize: { min: 1000, max: 50000 },
          typicalTimeline: '2-4 weeks',
          lastProfileUpdate: new Date(),
          categoryTags: [],
          experienceLevel: 'intermediate',
          verificationStatus: {
            skillsVerified: false,
            portfolioVerified: false,
            identityVerified: false
          }
        },
        locationData: {
          coordinates: { latitude: 0, longitude: 0 },
          address: { city: '', state: '', country: 'India', postalCode: '' },
          deliveryRadius: 50,
          serviceAreas: [],
          deliveryOptions: [],
          locationAccuracy: 100,
          lastLocationUpdate: new Date()
        },
        performanceMetrics: {
          responseTime: 24,
          completionRate: 0.95,
          customerSatisfaction: 4.5,
          repeatCustomerRate: 0.3,
          totalOrders: 0,
          successfulDeliveries: 0,
          averageOrderValue: 5000,
          lastActiveDate: new Date(),
          profileViews: 0,
          contactRequests: 0
        }
      };
    }

    // Update matching data
    if (updatedArtisan.artisanConnectProfile.matchingData) {
      updatedArtisan.artisanConnectProfile.matchingData = {
        ...updatedArtisan.artisanConnectProfile.matchingData,
        skills: enhancedProfile.matchingKeywords,
        materials: enhancedProfile.primaryMaterials,
        techniques: enhancedProfile.techniques,
        portfolioKeywords: enhancedProfile.portfolioKeywords,
        categoryTags: enhancedProfile.categoryTags,
        experienceLevel: enhancedProfile.experienceLevel,
        lastProfileUpdate: new Date()
      };
    }

    // Update specializations
    if (enhancedProfile.specializations.length > 0) {
      updatedArtisan.artisanConnectProfile.specializations = enhancedProfile.specializations;
    }

    return updatedArtisan;
  }

  // Private helper methods

  private async analyzeExistingProfile(artisan: IUser): Promise<ProfileAnalysisResult> {
    const profileText = this.gatherProfileText(artisan);
    
    if (!profileText.trim()) {
      return this.generateBasicAnalysis(artisan);
    }

    try {
      const prompt = this.buildProfileAnalysisPrompt(profileText, artisan.artisticProfession);
      const analysis = await this.aiService.extractRequirements(prompt);
      
      return {
        extractedKeywords: this.extractKeywordsFromText(profileText),
        detectedMaterials: analysis.materials,
        identifiedTechniques: analysis.techniques,
        suggestedCategories: analysis.products,
        qualityIndicators: this.detectQualityIndicators(profileText),
        experienceIndicators: this.detectExperienceIndicators(profileText),
        confidence: 0.7
      };
    } catch (error) {
      console.error('Error analyzing profile:', error);
      return this.generateBasicAnalysis(artisan);
    }
  }

  private generateEnhancedProfile(
    artisan: IUser, 
    analysis: ProfileAnalysisResult
  ): EnhancedMatchingProfile {
    const profession = artisan.artisticProfession?.toLowerCase() || 'general';
    const professionData = this.professionKeywords[profession as keyof typeof this.professionKeywords];
    
    return {
      uid: artisan.uid,
      professionCategories: [profession],
      primaryMaterials: this.mergeMaterials(analysis.detectedMaterials, professionData?.materials || []),
      techniques: this.mergeTechniques(analysis.identifiedTechniques, professionData?.techniques || []),
      specializations: this.extractSpecializations(artisan, analysis),
      styleExpertise: this.extractStyleExpertise(artisan, analysis),
      productTypes: this.mergeProducts(analysis.suggestedCategories, professionData?.products || []),
      qualityLevel: this.determineQualityLevel(analysis.qualityIndicators),
      experienceLevel: this.determineExperienceLevel(analysis.experienceIndicators, artisan),
      matchingKeywords: this.generateMatchingKeywords(artisan, analysis, professionData),
      portfolioKeywords: analysis.extractedKeywords,
      categoryTags: analysis.suggestedCategories,
      lastUpdated: new Date(),
      autoGenerated: true,
      confidence: analysis.confidence
    };
  }

  private generateBasicEnhancedProfile(artisan: IUser): EnhancedMatchingProfile {
    const profession = artisan.artisticProfession?.toLowerCase() || 'general';
    const professionData = this.professionKeywords[profession as keyof typeof this.professionKeywords];
    
    return {
      uid: artisan.uid,
      professionCategories: [profession],
      primaryMaterials: professionData?.materials.slice(0, 3) || [],
      techniques: professionData?.techniques.slice(0, 3) || [],
      specializations: artisan.artisanConnectProfile?.specializations || [],
      styleExpertise: [],
      productTypes: professionData?.products.slice(0, 5) || [],
      qualityLevel: 'standard',
      experienceLevel: artisan.artisanConnectProfile?.matchingData?.experienceLevel || 'intermediate',
      matchingKeywords: professionData?.keywords || [],
      portfolioKeywords: [],
      categoryTags: [],
      lastUpdated: new Date(),
      autoGenerated: true,
      confidence: 0.3
    };
  }

  private gatherProfileText(artisan: IUser): string {
    const textParts: string[] = [];
    
    if (artisan.description) textParts.push(artisan.description);
    if (artisan.artisticProfession) textParts.push(artisan.artisticProfession);
    
    const specializations = artisan.artisanConnectProfile?.specializations || [];
    textParts.push(...specializations);
    
    const portfolioHighlights = artisan.artisanConnectProfile?.portfolioHighlights || [];
    textParts.push(...portfolioHighlights);
    
    const skills = artisan.artisanConnectProfile?.matchingData?.skills || [];
    textParts.push(...skills);
    
    return textParts.join(' ').trim();
  }

  private buildKeywordExtractionPrompt(text: string, profession: string): string {
    return `Extract relevant keywords from this artisan's profile for profession matching.

Profile Text: "${text}"
Profession: ${profession}

Extract keywords related to:
- Skills and techniques
- Materials and tools
- Product types
- Specializations
- Style preferences

Return only the most relevant keywords separated by commas.`;
  }

  private buildProfileAnalysisPrompt(text: string, profession: string): string {
    return `Analyze this artisan profile and extract structured information for matching purposes.

Profile Text: "${text}"
Profession: ${profession}

Extract and categorize information about materials, techniques, products, and specializations they work with.`;
  }

  private parseKeywordsFromResponse(response: any): string[] {
    // Extract keywords from AI response
    const text = response.context || '';
    return text.split(',').map((keyword: string) => keyword.trim()).filter((k: string) => k.length > 0);
  }

  private extractKeywordsFromText(text: string): string[] {
    // Simple keyword extraction from text
    const words = text.toLowerCase().split(/\s+/);
    const relevantWords = words.filter(word => 
      word.length > 3 && 
      !['the', 'and', 'for', 'with', 'this', 'that', 'have', 'been', 'will'].includes(word)
    );
    
    return [...new Set(relevantWords)].slice(0, 20);
  }

  private getDefaultKeywords(profession?: string): string[] {
    if (!profession) return [];
    
    const professionLower = profession.toLowerCase();
    const professionData = this.professionKeywords[professionLower as keyof typeof this.professionKeywords];
    
    return professionData?.keywords || [];
  }

  private generateBasicAnalysis(artisan: IUser): ProfileAnalysisResult {
    const profession = artisan.artisticProfession?.toLowerCase() || 'general';
    const professionData = this.professionKeywords[profession as keyof typeof this.professionKeywords];
    
    return {
      extractedKeywords: professionData?.keywords || [],
      detectedMaterials: professionData?.materials.slice(0, 3) || [],
      identifiedTechniques: professionData?.techniques.slice(0, 3) || [],
      suggestedCategories: professionData?.products.slice(0, 3) || [],
      qualityIndicators: [],
      experienceIndicators: [],
      confidence: 0.3
    };
  }

  private mergeMaterials(detected: string[], defaults: string[]): string[] {
    return [...new Set([...detected, ...defaults])].slice(0, 10);
  }

  private mergeTechniques(detected: string[], defaults: string[]): string[] {
    return [...new Set([...detected, ...defaults])].slice(0, 8);
  }

  private mergeProducts(detected: string[], defaults: string[]): string[] {
    return [...new Set([...detected, ...defaults])].slice(0, 12);
  }

  private extractSpecializations(artisan: IUser, analysis: ProfileAnalysisResult): string[] {
    const existing = artisan.artisanConnectProfile?.specializations || [];
    const fromAnalysis = analysis.suggestedCategories.slice(0, 3);
    
    return [...new Set([...existing, ...fromAnalysis])].slice(0, 5);
  }

  private extractStyleExpertise(artisan: IUser, analysis: ProfileAnalysisResult): string[] {
    // Extract style-related keywords from analysis
    const styleKeywords = analysis.extractedKeywords.filter(keyword => 
      ['traditional', 'modern', 'contemporary', 'vintage', 'classic', 'rustic', 'elegant'].some(style => 
        keyword.includes(style)
      )
    );
    
    return styleKeywords.slice(0, 3);
  }

  private detectQualityIndicators(text: string): string[] {
    const qualityWords = ['premium', 'luxury', 'high-end', 'quality', 'fine', 'artisan', 'handcrafted', 'bespoke'];
    const textLower = text.toLowerCase();
    
    return qualityWords.filter(word => textLower.includes(word));
  }

  private detectExperienceIndicators(text: string): string[] {
    const experienceWords = ['master', 'expert', 'experienced', 'years', 'decades', 'traditional', 'heritage'];
    const textLower = text.toLowerCase();
    
    return experienceWords.filter(word => textLower.includes(word));
  }

  private determineQualityLevel(indicators: string[]): 'premium' | 'standard' | 'basic' {
    const premiumWords = ['premium', 'luxury', 'high-end', 'bespoke', 'fine'];
    
    if (indicators.some(indicator => premiumWords.includes(indicator))) {
      return 'premium';
    }
    
    if (indicators.length > 0) {
      return 'standard';
    }
    
    return 'basic';
  }

  private determineExperienceLevel(
    indicators: string[], 
    artisan: IUser
  ): 'master' | 'experienced' | 'intermediate' | 'beginner' {
    const existing = artisan.artisanConnectProfile?.matchingData?.experienceLevel;
    if (existing && existing !== 'intermediate') {
      return existing;
    }
    
    const masterWords = ['master', 'decades', 'heritage'];
    const expertWords = ['expert', 'experienced', 'years'];
    
    if (indicators.some(indicator => masterWords.includes(indicator))) {
      return 'master';
    }
    
    if (indicators.some(indicator => expertWords.includes(indicator))) {
      return 'experienced';
    }
    
    const totalOrders = artisan.artisanConnectProfile?.performanceMetrics?.totalOrders || 0;
    if (totalOrders > 100) return 'experienced';
    if (totalOrders > 20) return 'intermediate';
    
    return 'beginner';
  }

  private generateMatchingKeywords(
    artisan: IUser, 
    analysis: ProfileAnalysisResult, 
    professionData?: any
  ): string[] {
    const keywords: string[] = [];
    
    // Add profession-specific keywords
    if (professionData?.keywords) {
      keywords.push(...professionData.keywords);
    }
    
    // Add extracted keywords
    keywords.push(...analysis.extractedKeywords.slice(0, 10));
    
    // Add materials and techniques as keywords
    keywords.push(...analysis.detectedMaterials);
    keywords.push(...analysis.identifiedTechniques);
    
    // Add profession name variations
    if (artisan.artisticProfession) {
      keywords.push(artisan.artisticProfession);
      keywords.push(artisan.artisticProfession.toLowerCase());
    }
    
    return [...new Set(keywords)].slice(0, 25);
  }

  private delay(ms: number): Promise<void> {
    return new Promise(resolve => setTimeout(resolve, ms));
  }
}